## 案例1：查询每个科目排名前三的学生和成绩
**业务场景**：学校教务系统需要展示各科目成绩前三名的学生名单，用于表彰优秀学生。  
**SQL书写逻辑**：
1. 使用窗口函数DENSE_RANK()按科目分组对成绩进行排名
2. 通过PARTITION BY subject确保每个科目单独排名
3. 筛选rank值小于等于3的记录
4. 按科目和排名排序输出结果

```sql
WITH student_scores AS (
    SELECT
        student_id,
        student_name,
        subject,
        score,
        DENSE_RANK() OVER (PARTITION BY subject ORDER BY score DESC) AS score_rank
    FROM exam_results
)
SELECT
    subject,
    student_name,
    score
FROM student_scores
WHERE score_rank <= 3
ORDER BY subject, score_rank;
```


## DDL语句和示例数据
```sql
-- DDL
CREATE TABLE exam_results (
    id INT PRIMARY KEY AUTO_INCREMENT,
    student_id INT NOT NULL,
    student_name VARCHAR(50) NOT NULL,
    class_id VARCHAR(20) NOT NULL,
    subject VARCHAR(30) NOT NULL,
    score DECIMAL(5,2) NOT NULL,
    exam_date DATE NOT NULL,
    INDEX idx_subject_score (subject, score DESC),
    INDEX idx_student (student_id)
);

-- 示例数据
INSERT INTO exam_results (student_id, student_name, class_id, subject, score, exam_date) VALUES
(101, '张三', 'A101', '数学', 95.5, '2023-09-15'),
(101, '张三', 'A101', '语文', 88.0, '2023-09-15'),
(102, '李四', 'A101', '数学', 92.0, '2023-09-15'),
(102, '李四', 'A101', '语文', 85.5, '2023-09-15'),
(103, '王五', 'A101', '数学', 98.0, '2023-09-15'),
(103, '王五', 'A101', '语文', 90.0, '2023-09-15'),
(104, '赵六', 'A101', '数学', 89.0, '2023-09-15'),
(104, '赵六', 'A101', '语文', 92.5, '2023-09-15'),
(105, '钱七', 'A101', '数学', 91.0, '2023-09-15'),
(105, '钱七', 'A101', '语文', 87.0, '2023-09-15');
```


## 案例2：计算某店7月"蚂蚁上树"销量同比增长率
**业务场景**：餐饮连锁企业需要分析各门店招牌菜品的年度销售增长情况。  
**SQL书写逻辑**：
1. 分别查询今年7月和去年7月的销售总量
2. 使用CROSS JOIN将两个结果集合并
3. 计算同比增长率：(今年销量-去年销量)/去年销量*100
4. 保留两位小数输出结果

```sql
SELECT
    current_month.sales AS current_sales,
    last_year.sales AS last_year_sales,
    ROUND((current_month.sales - last_year.sales) / last_year.sales * 100, 2) AS growth_rate
FROM (
    SELECT SUM(quantity) AS sales
    FROM sales_records
    WHERE product_name = '蚂蚁上树'
    AND store_id = 101
    AND sale_date BETWEEN '2023-07-01' AND '2023-07-31'
) AS current_month
CROSS JOIN (
    SELECT SUM(quantity) AS sales
    FROM sales_records
    WHERE product_name = '蚂蚁上树'
    AND store_id = 101
    AND sale_date BETWEEN '2022-07-01' AND '2022-07-31'
) AS last_year;
```

## DDL语句和示例数据
```sql
-- DDL
CREATE TABLE sales_records (
    id INT PRIMARY KEY AUTO_INCREMENT,
    store_id INT NOT NULL,
    product_name VARCHAR(50) NOT NULL,
    quantity INT NOT NULL,
    sale_date DATE NOT NULL,
    amount DECIMAL(10,2) NOT NULL,
    INDEX idx_store_product (store_id, product_name),
    INDEX idx_date (sale_date)
);

-- 示例数据
INSERT INTO sales_records (store_id, product_name, quantity, sale_date, amount) VALUES
(101, '蚂蚁上树', 120, '2022-07-01', 2400.00),
(101, '蚂蚁上树', 150, '2022-07-15', 3000.00),
(101, '蚂蚁上树', 80, '2023-07-05', 1600.00),
(101, '蚂蚁上树', 200, '2023-07-20', 4000.00),
(101, '宫保鸡丁', 90, '2023-07-10', 2700.00),
(102, '蚂蚁上树', 70, '2023-07-08', 1400.00);
```

## 案例3：找出连续3天登录的用户
**业务场景**：互联网产品运营需要识别高活跃用户进行精准营销。  
**SQL书写逻辑**：
1. 通过自连接找出同一用户连续3天登录的记录
2. 第一个表(a)作为基准日期
3. 第二个表(b)查找次日登录记录
4. 第三个表(c)查找第三日登录记录
5. 使用DISTINCT去重

```sql
SELECT DISTINCT a.user_id
FROM user_logins a
JOIN user_logins b ON a.user_id = b.user_id
    AND b.login_date = DATE_ADD(a.login_date, INTERVAL 1 DAY)
JOIN user_logins c ON a.user_id = c.user_id
    AND c.login_date = DATE_ADD(a.login_date, INTERVAL 2 DAY)
WHERE a.login_date >= '2023-08-01';
```

## DDL语句和示例数据
```sql
-- DDL
CREATE TABLE user_logins (
    id INT PRIMARY KEY AUTO_INCREMENT,
    user_id INT NOT NULL,
    login_date DATE NOT NULL,
    device_type VARCHAR(20),
    INDEX idx_user_date (user_id, login_date)
);

-- 示例数据
INSERT INTO user_logins (user_id, login_date, device_type) VALUES
(1001, '2023-08-01', 'Mobile'),
(1001, '2023-08-02', 'PC'),
(1001, '2023-08-03', 'Mobile'),
(1002, '2023-08-01', 'PC'),
(1002, '2023-08-03', 'Mobile'),
(1003, '2023-08-05', 'Mobile'),
(1003, '2023-08-06', 'Mobile'),
(1003, '2023-08-07', 'PC'),
(1004, '2023-08-10', 'Mobile'),
(1004, '2023-08-11', 'Mobile'),
(1004, '2023-08-12', 'Mobile');
```

## 案例4：计算用户留存率（次日/7日/30日）
**业务场景**：移动应用需要分析不同时期用户的质量和粘性。  
**SQL书写逻辑**：
1. 先找出每个用户的首次登录日
2. 左连接所有登录记录
3. 使用条件聚合计算不同时间窗口的留存用户数
4. 计算留存率并保留两位小数
5. 按首次登录日排序

```sql
SELECT
    first_day,
    COUNT(DISTINCT first_login.user_id) AS new_users,
    ROUND(COUNT(DISTINCT CASE WHEN user_logins.login_date = DATE_ADD(first_day, INTERVAL 1 DAY) THEN first_login.user_id END) /
          COUNT(DISTINCT first_login.user_id) * 100, 2) AS day1_retention,
    ROUND(COUNT(DISTINCT CASE WHEN user_logins.login_date BETWEEN DATE_ADD(first_day, INTERVAL 1 DAY) AND DATE_ADD(first_day, INTERVAL 7 DAY) THEN first_login.user_id END) /
          COUNT(DISTINCT first_login.user_id) * 100, 2) AS day7_retention,
    ROUND(COUNT(DISTINCT CASE WHEN user_logins.login_date BETWEEN DATE_ADD(first_day, INTERVAL 1 DAY) AND DATE_ADD(first_day, INTERVAL 30 DAY) THEN first_login.user_id END) /
          COUNT(DISTINCT first_login.user_id) * 100, 2) AS day30_retention
FROM (
    SELECT
        user_id,
        MIN(login_date) AS first_day
    FROM user_logins
    GROUP BY user_id
) AS first_login
LEFT JOIN user_logins ON user_logins.user_id = first_login.user_id
GROUP BY first_day
ORDER BY first_day;
```

## DDL语句和示例数据
```sql
-- DDL
CREATE TABLE user_behavior (
    id INT PRIMARY KEY AUTO_INCREMENT,
    user_id INT NOT NULL,
    event_date DATE NOT NULL,
    event_type ENUM('register', 'login', 'purchase') NOT NULL,
    INDEX idx_user_date (user_id, event_date)
);

-- 示例数据
INSERT INTO user_behavior (user_id, event_date, event_type) VALUES
(1001, '2023-10-01', 'register'),
(1001, '2023-10-01', 'login'),
(1001, '2023-10-02', 'login'),
(1001, '2023-10-05', 'purchase'),
(1002, '2023-10-01', 'register'),
(1002, '2023-10-08', 'login'),
(1003, '2023-10-15', 'register'),
(1003, '2023-10-16', 'login'),
(1003, '2023-10-20', 'purchase'),
(1004, '2023-10-01', 'register'),
(1004, '2023-10-02', 'login'),
(1004, '2023-10-30', 'purchase');
```

## 案例5：识别购物篮关联商品（经常一起购买的商品组合）
**业务场景**：电商平台需要分析商品关联性，优化商品推荐和货架摆放。  
**SQL书写逻辑**：
1. 自连接order_items表，查找同一订单中的不同商品
2. 使用a.product_id < b.product_id避免重复组合
3. 按商品组合分组统计出现次数
4. 筛选出现10次以上的组合
5. 按出现次数降序排列，限制输出20条

```sql
SELECT
    a.product_name AS product1,
    b.product_name AS product2,
    COUNT(*) AS combo_count
FROM order_items a
JOIN order_items b ON a.order_id = b.order_id AND a.product_id < b.product_id
GROUP BY a.product_name, b.product_name
HAVING COUNT(*) >= 2
ORDER BY combo_count DESC
LIMIT 20;
```


## DDL语句和示例数据
```sql
-- DDL
CREATE TABLE order_items (
    id INT PRIMARY KEY AUTO_INCREMENT,
    order_id INT NOT NULL,
    product_id INT NOT NULL,
    product_name VARCHAR(50) NOT NULL,
    quantity INT NOT NULL,
    price DECIMAL(10,2) NOT NULL,
    INDEX idx_order (order_id),
    INDEX idx_product (product_id)
);

-- 示例数据
INSERT INTO order_items (order_id, product_id, product_name, quantity, price) VALUES
(10001, 101, 'iPhone 13', 1, 5999.00),
(10001, 102, 'AirPods Pro', 1, 1499.00),
(10002, 101, 'iPhone 13', 1, 5999.00),
(10002, 103, 'MagSafe充电器', 1, 329.00),
(10003, 102, 'AirPods Pro', 2, 1499.00),
(10003, 103, 'MagSafe充电器', 1, 329.00),
(10004, 104, 'iPad Air', 1, 4399.00),
(10004, 105, 'Apple Pencil', 1, 999.00),
(10005, 101, 'iPhone 13', 1, 5999.00),
(10005, 105, 'Apple Pencil', 1, 999.00);
```

## 案例6：计算员工薪资部门占比
**业务场景**：HR部门需要分析员工薪资在部门和全公司的占比情况。  
**SQL书写逻辑**：
1. 连接employees和departments表获取完整信息
2. 使用窗口函数计算部门薪资总和(SUM OVER PARTITION BY department_id)
3. 使用窗口函数计算公司总薪资(SUM OVER)
4. 计算个人薪资占比并保留两位小数
5. 按部门和薪资降序排列

```sql
SELECT
    e.employee_id,
    e.employee_name,
    e.salary,
    d.department_name,
    ROUND(e.salary / SUM(e.salary) OVER (PARTITION BY e.department_id) * 100, 2) AS dept_salary_percent,
    ROUND(e.salary / SUM(e.salary) OVER () * 100, 2) AS total_salary_percent
FROM employees e
JOIN departments d ON e.department_id = d.department_id
ORDER BY e.department_id, e.salary DESC;
```


## DDL语句和示例数据
```sql
-- DDL
CREATE TABLE departments (
    department_id INT PRIMARY KEY,
    department_name VARCHAR(50) NOT NULL,
    location VARCHAR(50)
);

CREATE TABLE employees (
    employee_id INT PRIMARY KEY,
    employee_name VARCHAR(50) NOT NULL,
    department_id INT,
    salary DECIMAL(10,2) NOT NULL,
    hire_date DATE NOT NULL,
    FOREIGN KEY (department_id) REFERENCES departments(department_id)
);

-- 示例数据
INSERT INTO departments VALUES
(10, '研发部', '北京'),
(20, '市场部', '上海'),
(30, '财务部', '广州');

INSERT INTO employees VALUES
(1001, '张三', 10, 15000.00, '2020-06-15'),
(1002, '李四', 10, 18000.00, '2019-03-10'),
(1003, '王五', 20, 12000.00, '2021-01-20'),
(1004, '赵六', 20, 13500.00, '2020-11-05'),
(1005, '钱七', 30, 20000.00, '2018-07-22'),
(1006, '孙八', 30, 22000.00, '2017-09-30');
```

## 案例7：查询用户最近一次购买距今天数
**业务场景**：电商平台需要识别不同状态的用户群体，制定差异化营销策略。  
**SQL书写逻辑**：
1. 左连接users和orders表
2. 按用户分组找出最近订单日期
3. 计算与当前日期的差值
4. 使用CASE WHEN对用户进行分类
5. 按距今天数降序排列

```sql
SELECT
    u.user_id,
    u.user_name,
    DATEDIFF(CURRENT_DATE, MAX(o.order_date)) AS days_since_last_order,
    CASE
        WHEN DATEDIFF(CURRENT_DATE, MAX(o.order_date)) <= 30 THEN '活跃用户'
        WHEN DATEDIFF(CURRENT_DATE, MAX(o.order_date)) <= 90 THEN '沉默用户'
        ELSE '流失用户'
    END AS user_status
FROM users u
LEFT JOIN orders o ON u.user_id = o.user_id
GROUP BY u.user_id, u.user_name
ORDER BY days_since_last_order DESC;
```


## DDL语句和示例数据
```sql
-- DDL
CREATE TABLE users (
    user_id INT PRIMARY KEY,
    user_name VARCHAR(50) NOT NULL,
    register_date DATE NOT NULL,
    phone VARCHAR(20)
);

CREATE TABLE orders (
    order_id INT PRIMARY KEY,
    user_id INT NOT NULL,
    order_date DATETIME NOT NULL,
    amount DECIMAL(10,2) NOT NULL,
    status VARCHAR(20) NOT NULL,
    FOREIGN KEY (user_id) REFERENCES users(user_id),
    INDEX idx_user_date (user_id, order_date)
);

-- 示例数据
INSERT INTO users VALUES
(1001, '张三', '2022-01-15', '13800138001'),
(1002, '李四', '2022-03-20', '13800138002'),
(1003, '王五', '2022-05-10', '13800138003'),
(1004, '赵六', '2022-07-05', '13800138004');

INSERT INTO orders VALUES
(2001, 1001, '2023-06-10 14:30:00', 299.00, 'completed'),
(2002, 1001, '2023-07-15 10:15:00', 599.00, 'completed'),
(2003, 1002, '2023-08-05 16:45:00', 129.00, 'completed'),
(2004, 1003, '2023-09-20 11:20:00', 399.00, 'completed'),
(2005, 1003, '2023-10-01 09:30:00', 899.00, 'completed'),
(2006, 1004, '2023-10-15 13:10:00', 199.00, 'completed');
```

## 案例8：计算各月累计销售额
**业务场景**：财务部门需要分析销售业绩的月度趋势和累计完成情况。  
**SQL书写逻辑**：
1. 使用DATE_FORMAT将日期格式化为年月
2. 按月分组汇总销售额
3. 使用窗口函数SUM OVER计算累计销售额
4. 按月份排序输出结果

```sql
SELECT
    DATE_FORMAT(order_date, '%Y-%m') AS month,
    SUM(amount) AS monthly_sales,
    SUM(SUM(amount)) OVER (ORDER BY DATE_FORMAT(order_date, '%Y-%m')) AS cumulative_sales
FROM orders
WHERE order_date BETWEEN '2023-01-01' AND '2023-12-31'
GROUP BY DATE_FORMAT(order_date, '%Y-%m')
ORDER BY month;
```

## DDL语句和示例数据
```sql
-- DDL
CREATE TABLE sales (
    sale_id INT PRIMARY KEY,
    product_id INT NOT NULL,
    sale_date DATE NOT NULL,
    amount DECIMAL(10,2) NOT NULL,
    quantity INT NOT NULL,
    region VARCHAR(20),
    INDEX idx_date (sale_date)
);

-- 示例数据
INSERT INTO sales VALUES
(1, 101, '2023-01-05', 1000.00, 10, 'North'),
(2, 102, '2023-01-15', 1500.00, 15, 'South'),
(3, 101, '2023-02-10', 800.00, 8, 'East'),
(4, 103, '2023-02-20', 1200.00, 12, 'West'),
(5, 102, '2023-03-08', 900.00, 9, 'North'),
(6, 101, '2023-03-18', 1100.00, 11, 'South'),
(7, 103, '2023-04-05', 700.00, 7, 'East'),
(8, 102, '2023-04-25', 1300.00, 13, 'West'),
(9, 101, '2023-05-12', 950.00, 9, 'North'),
(10, 103, '2023-05-22', 1050.00, 10, 'South');
```

## 案例9：识别异常订单（金额超过3个标准差）
**业务场景**：风控部门需要识别可能存在问题的异常交易订单。  
**SQL书写逻辑**：
1. 使用CTE计算订单金额的均值和标准差
2. 主查询计算每个订单的Z-score(与均值的差/标准差)
3. 筛选绝对值大于3的异常订单
4. 按Z-score绝对值降序排列

```sql
WITH order_stats AS (
    SELECT
        AVG(amount) AS avg_amount,
        STDDEV(amount) AS std_amount
    FROM sale_orders
    WHERE order_date BETWEEN '2023-01-01' AND '2023-12-31'
)
SELECT
    o.order_id,
    o.customer_id,
    o.amount,
    s.avg_amount,
    s.std_amount,
    (o.amount - s.avg_amount) / s.std_amount AS z_score
FROM sale_orders o
CROSS JOIN order_stats s
WHERE o.order_date BETWEEN '2023-01-01' AND '2023-12-31'
AND ABS((o.amount - s.avg_amount) / s.std_amount) > 1
ORDER BY ABS(z_score) DESC;
```


## DDL语句和示例数据
```sql
-- DDL
CREATE TABLE sale_orders (
    order_id INT PRIMARY KEY,
    customer_id INT NOT NULL,
    order_date DATETIME NOT NULL,
    amount DECIMAL(10,2) NOT NULL,
    status VARCHAR(20) NOT NULL,
    payment_method VARCHAR(20),
    INDEX idx_date_amount (order_date, amount)
);

-- 示例数据
INSERT INTO sale_orders VALUES
(1001, 2001, '2023-01-05 10:30:00', 299.00, 'completed', 'credit_card'),
(1002, 2002, '2023-01-10 14:15:00', 599.00, 'completed', 'paypal'),
(1003, 2003, '2023-01-15 11:20:00', 1299.00, 'completed', 'credit_card'),
(1004, 2001, '2023-01-20 09:45:00', 199.00, 'completed', 'alipay'),
(1005, 2004, '2023-01-25 16:30:00', 8999.00, 'completed', 'credit_card'),  -- 异常订单
(1006, 2005, '2023-01-30 13:10:00', 399.00, 'completed', 'wechat_pay'),
(1007, 2002, '2023-02-05 15:20:00', 599.00, 'completed', 'credit_card'),
(1008, 2003, '2023-02-10 10:15:00', 129.00, 'completed', 'alipay'),
(1009, 2006, '2023-02-15 12:30:00', 9999.00, 'completed', 'credit_card'),  -- 异常订单
(1010, 2001, '2023-02-20 14:45:00', 499.00, 'completed', 'paypal');
```

## 案例10：计算员工薪资等级分布
**业务场景**：HR部门需要分析员工薪资在部门和全公司的占比情况。  
**SQL书写逻辑**：
1. 连接employees和departments表获取完整信息
2. 使用窗口函数计算部门薪资总和(SUM OVER PARTITION BY department_id)
3. 使用窗口函数计算公司总薪资(SUM OVER)
4. 计算个人薪资占比并保留两位小数
5. 按部门和薪资降序排列

```sql
SELECT
    e.employee_id,
    e.employee_name,
    e.salary,
    d.department_name,
    ROUND(e.salary / SUM(e.salary) OVER (PARTITION BY e.department_id) * 100, 2) AS dept_salary_percent,
    ROUND(e.salary / SUM(e.salary) OVER () * 100, 2) AS total_salary_percent
FROM employees e
JOIN departments d ON e.department_id = d.department_id
ORDER BY e.department_id, e.salary DESC;
```


## DDL语句和示例数据
```sql
-- DDL
CREATE TABLE departments (
    department_id INT PRIMARY KEY,
    department_name VARCHAR(50) NOT NULL,
    location VARCHAR(50)
);

CREATE TABLE employees (
    employee_id INT PRIMARY KEY,
    employee_name VARCHAR(50) NOT NULL,
    department_id INT,
    salary DECIMAL(10,2) NOT NULL,
    hire_date DATE NOT NULL,
    FOREIGN KEY (department_id) REFERENCES departments(department_id)
);

-- 示例数据
INSERT INTO departments VALUES
(10, '研发部', '北京'),
(20, '市场部', '上海'),
(30, '财务部', '广州');

INSERT INTO employees VALUES
(1001, '张三', 10, 15000.00, '2020-06-15'),
(1002, '李四', 10, 18000.00, '2019-03-10'),
(1003, '王五', 20, 12000.00, '2021-01-20'),
(1004, '赵六', 20, 13500.00, '2020-11-05'),
(1005, '钱七', 30, 20000.00, '2018-07-22'),
(1006, '孙八', 30, 22000.00, '2017-09-30');
```

## 案例11：计算班级连续3个月月考均前五的学生各科成绩
**业务场景**：学校教务系统需要展示各科目成绩前三名的学生名单，用于表彰优秀学生。  
**SQL书写逻辑**：
1. 使用窗口函数DENSE_RANK()按科目分组对成绩进行排名
2. 通过PARTITION BY subject确保每个科目单独排名
3. 筛选rank值小于等于3的记录
4. 按科目和排名排序输出结果

```sql
WITH student_scores AS (
    SELECT
        student_id,
        student_name,
        subject,
        score,
        DENSE_RANK() OVER (PARTITION BY subject ORDER BY score DESC) AS score_rank
    FROM exam_results
)
SELECT
    subject,
    student_name,
    score
FROM student_scores
WHERE score_rank <= 3
ORDER BY subject, score_rank;
```


## DDL语句和示例数据
```sql
-- DDL
CREATE TABLE exam_results (
    id INT PRIMARY KEY AUTO_INCREMENT,
    student_id INT NOT NULL,
    student_name VARCHAR(50) NOT NULL,
    class_id VARCHAR(20) NOT NULL,
    subject VARCHAR(30) NOT NULL,
    score DECIMAL(5,2) NOT NULL,
    exam_date DATE NOT NULL,
    INDEX idx_subject_score (subject, score DESC),
    INDEX idx_student (student_id)
);

-- 示例数据
INSERT INTO exam_results (student_id, student_name, class_id, subject, score, exam_date) VALUES
(101, '张三', 'A101', '数学', 95.5, '2023-09-15'),
(101, '张三', 'A101', '语文', 88.0, '2023-09-15'),
(102, '李四', 'A101', '数学', 92.0, '2023-09-15'),
(102, '李四', 'A101', '语文', 85.5, '2023-09-15'),
(103, '王五', 'A101', '数学', 98.0, '2023-09-15'),
(103, '王五', 'A101', '语文', 90.0, '2023-09-15'),
(104, '赵六', 'A101', '数学', 89.0, '2023-09-15'),
(104, '赵六', 'A101', '语文', 92.5, '2023-09-15'),
(105, '钱七', 'A101', '数学', 91.0, '2023-09-15'),
(105, '钱七', 'A101', '语文', 87.0, '2023-09-15');
```

## 案例12：计算电商商品复购周期（平均购买间隔）
**业务场景**：餐饮连锁企业需要分析各门店招牌菜品的年度销售增长情况。  
**SQL书写逻辑**：
1. 分别查询今年7月和去年7月的销售总量
2. 使用CROSS JOIN将两个结果集合并
3. 计算同比增长率：(今年销量-去年销量)/去年销量*100
4. 保留两位小数输出结果

```sql
SELECT
    current_month.sales AS current_sales,
    last_year.sales AS last_year_sales,
    ROUND((current_month.sales - last_year.sales) / last_year.sales * 100, 2) AS growth_rate
FROM (
    SELECT SUM(quantity) AS sales
    FROM sales_records
    WHERE product_name = '蚂蚁上树'
    AND store_id = 101
    AND sale_date BETWEEN '2023-07-01' AND '2023-07-31'
) AS current_month
CROSS JOIN (
    SELECT SUM(quantity) AS sales
    FROM sales_records
    WHERE product_name = '蚂蚁上树'
    AND store_id = 101
    AND sale_date BETWEEN '2022-07-01' AND '2022-07-31'
) AS last_year;
```

## DDL语句和示例数据
```sql
-- DDL
CREATE TABLE sales_records (
    id INT PRIMARY KEY AUTO_INCREMENT,
    store_id INT NOT NULL,
    product_name VARCHAR(50) NOT NULL,
    quantity INT NOT NULL,
    sale_date DATE NOT NULL,
    amount DECIMAL(10,2) NOT NULL,
    INDEX idx_store_product (store_id, product_name),
    INDEX idx_date (sale_date)
);

-- 示例数据
INSERT INTO sales_records (store_id, product_name, quantity, sale_date, amount) VALUES
(101, '蚂蚁上树', 120, '2022-07-01', 2400.00),
(101, '蚂蚁上树', 150, '2022-07-15', 3000.00),
(101, '蚂蚁上树', 80, '2023-07-05', 1600.00),
(101, '蚂蚁上树', 200, '2023-07-20', 4000.00),
(101, '宫保鸡丁', 90, '2023-07-10', 2700.00),
(102, '蚂蚁上树', 70, '2023-07-08', 1400.00);
```

## 案例13：识别信用卡异常消费模式
**业务场景**：风控部门需要识别可能存在问题的异常交易订单。  
**SQL书写逻辑**：
1. 使用CTE计算订单金额的均值和标准差
2. 主查询计算每个订单的Z-score(与均值的差/标准差)
3. 筛选绝对值大于3的异常订单
4. 按Z-score绝对值降序排列

```sql
WITH order_stats AS (
    SELECT
        AVG(amount) AS avg_amount,
        STDDEV(amount) AS std_amount
    FROM sale_orders
    WHERE order_date BETWEEN '2023-01-01' AND '2023-12-31'
)
SELECT
    o.order_id,
    o.customer_id,
    o.amount,
    s.avg_amount,
    s.std_amount,
    (o.amount - s.avg_amount) / s.std_amount AS z_score
FROM sale_orders o
CROSS JOIN order_stats s
WHERE o.order_date BETWEEN '2023-01-01' AND '2023-12-31'
AND ABS((o.amount - s.avg_amount) / s.std_amount) > 1
ORDER BY ABS(z_score) DESC;
```


## DDL语句和示例数据
```sql
-- DDL
CREATE TABLE sale_orders (
    order_id INT PRIMARY KEY,
    customer_id INT NOT NULL,
    order_date DATETIME NOT NULL,
    amount DECIMAL(10,2) NOT NULL,
    status VARCHAR(20) NOT NULL,
    payment_method VARCHAR(20),
    INDEX idx_date_amount (order_date, amount)
);

-- 示例数据
INSERT INTO sale_orders VALUES
(1001, 2001, '2023-01-05 10:30:00', 299.00, 'completed', 'credit_card'),
(1002, 2002, '2023-01-10 14:15:00', 599.00, 'completed', 'paypal'),
(1003, 2003, '2023-01-15 11:20:00', 1299.00, 'completed', 'credit_card'),
(1004, 2001, '2023-01-20 09:45:00', 199.00, 'completed', 'alipay'),
(1005, 2004, '2023-01-25 16:30:00', 8999.00, 'completed', 'credit_card'),  -- 异常订单
(1006, 2005, '2023-01-30 13:10:00', 399.00, 'completed', 'wechat_pay'),
(1007, 2002, '2023-02-05 15:20:00', 599.00, 'completed', 'credit_card'),
(1008, 2003, '2023-02-10 10:15:00', 129.00, 'completed', 'alipay'),
(1009, 2006, '2023-02-15 12:30:00', 9999.00, 'completed', 'credit_card'),  -- 异常订单
(1010, 2001, '2023-02-20 14:45:00', 499.00, 'completed', 'paypal');
```

## 案例14：计算零售商品季节性销售指数
**业务场景**：餐饮连锁企业需要分析各门店招牌菜品的年度销售增长情况。  
**SQL书写逻辑**：
1. 分别查询今年7月和去年7月的销售总量
2. 使用CROSS JOIN将两个结果集合并
3. 计算同比增长率：(今年销量-去年销量)/去年销量*100
4. 保留两位小数输出结果

```sql
SELECT
    current_month.sales AS current_sales,
    last_year.sales AS last_year_sales,
    ROUND((current_month.sales - last_year.sales) / last_year.sales * 100, 2) AS growth_rate
FROM (
    SELECT SUM(quantity) AS sales
    FROM sales_records
    WHERE product_name = '蚂蚁上树'
    AND store_id = 101
    AND sale_date BETWEEN '2023-07-01' AND '2023-07-31'
) AS current_month
CROSS JOIN (
    SELECT SUM(quantity) AS sales
    FROM sales_records
    WHERE product_name = '蚂蚁上树'
    AND store_id = 101
    AND sale_date BETWEEN '2022-07-01' AND '2022-07-31'
) AS last_year;
```

## 案例15：计算网约车司机接单效率（接单率/取消率）
**业务场景**：餐饮连锁企业需要分析各门店招牌菜品的年度销售增长情况。  
**SQL书写逻辑**：
1. 分别查询今年7月和去年7月的销售总量
2. 使用CROSS JOIN将两个结果集合并
3. 计算同比增长率：(今年销量-去年销量)/去年销量*100
4. 保留两位小数输出结果

```sql
SELECT
    current_month.sales AS current_sales,
    last_year.sales AS last_year_sales,
    ROUND((current_month.sales - last_year.sales) / last_year.sales * 100, 2) AS growth_rate
FROM (
    SELECT SUM(quantity) AS sales
    FROM sales_records
    WHERE product_name = '蚂蚁上树'
    AND store_id = 101
    AND sale_date BETWEEN '2023-07-01' AND '2023-07-31'
) AS current_month
CROSS JOIN (
    SELECT SUM(quantity) AS sales
    FROM sales_records
    WHERE product_name = '蚂蚁上树'
    AND store_id = 101
    AND sale_date BETWEEN '2022-07-01' AND '2022-07-31'
) AS last_year;
```

## 案例16：计算广告渠道ROI（投入产出比）
**业务场景**：餐饮连锁企业需要分析各门店招牌菜品的年度销售增长情况。  
**SQL书写逻辑**：
1. 分别查询今年7月和去年7月的销售总量
2. 使用CROSS JOIN将两个结果集合并
3. 计算同比增长率：(今年销量-去年销量)/去年销量*100
4. 保留两位小数输出结果

```sql
SELECT
    current_month.sales AS current_sales,
    last_year.sales AS last_year_sales,
    ROUND((current_month.sales - last_year.sales) / last_year.sales * 100, 2) AS growth_rate
FROM (
    SELECT SUM(quantity) AS sales
    FROM sales_records
    WHERE product_name = '蚂蚁上树'
    AND store_id = 101
    AND sale_date BETWEEN '2023-07-01' AND '2023-07-31'
) AS current_month
CROSS JOIN (
    SELECT SUM(quantity) AS sales
    FROM sales_records
    WHERE product_name = '蚂蚁上树'
    AND store_id = 101
    AND sale_date BETWEEN '2022-07-01' AND '2022-07-31'
) AS last_year;
```

## 案例17：识别供应链异常交货（提前/延迟交货分析）
**业务场景**：餐饮连锁企业需要分析各门店招牌菜品的年度销售增长情况。  
**SQL书写逻辑**：
1. 分别查询今年7月和去年7月的销售总量
2. 使用CROSS JOIN将两个结果集合并
3. 计算同比增长率：(今年销量-去年销量)/去年销量*100
4. 保留两位小数输出结果

```sql
SELECT
    current_month.sales AS current_sales,
    last_year.sales AS last_year_sales,
    ROUND((current_month.sales - last_year.sales) / last_year.sales * 100, 2) AS growth_rate
FROM (
    SELECT SUM(quantity) AS sales
    FROM sales_records
    WHERE product_name = '蚂蚁上树'
    AND store_id = 101
    AND sale_date BETWEEN '2023-07-01' AND '2023-07-31'
) AS current_month
CROSS JOIN (
    SELECT SUM(quantity) AS sales
    FROM sales_records
    WHERE product_name = '蚂蚁上树'
    AND store_id = 101
    AND sale_date BETWEEN '2022-07-01' AND '2022-07-31'
) AS last_year;
```

## 案例18：识别供应链异常交货（提前/延迟交货分析）
**业务场景**：餐饮连锁企业需要分析各门店招牌菜品的年度销售增长情况。  
**SQL书写逻辑**：
1. 分别查询今年7月和去年7月的销售总量
2. 使用CROSS JOIN将两个结果集合并
3. 计算同比增长率：(今年销量-去年销量)/去年销量*100
4. 保留两位小数输出结果

```sql
SELECT
    current_month.sales AS current_sales,
    last_year.sales AS last_year_sales,
    ROUND((current_month.sales - last_year.sales) / last_year.sales * 100, 2) AS growth_rate
FROM (
    SELECT SUM(quantity) AS sales
    FROM sales_records
    WHERE product_name = '蚂蚁上树'
    AND store_id = 101
    AND sale_date BETWEEN '2023-07-01' AND '2023-07-31'
) AS current_month
CROSS JOIN (
    SELECT SUM(quantity) AS sales
    FROM sales_records
    WHERE product_name = '蚂蚁上树'
    AND store_id = 101
    AND sale_date BETWEEN '2022-07-01' AND '2022-07-31'
) AS last_year;
```

## 案例19：计算客户生命周期价值（LTV）
**业务场景**：餐饮连锁企业需要分析各门店招牌菜品的年度销售增长情况。  
**SQL书写逻辑**：
1. 分别查询今年7月和去年7月的销售总量
2. 使用CROSS JOIN将两个结果集合并
3. 计算同比增长率：(今年销量-去年销量)/去年销量*100
4. 保留两位小数输出结果

```sql
SELECT
    current_month.sales AS current_sales,
    last_year.sales AS last_year_sales,
    ROUND((current_month.sales - last_year.sales) / last_year.sales * 100, 2) AS growth_rate
FROM (
    SELECT SUM(quantity) AS sales
    FROM sales_records
    WHERE product_name = '蚂蚁上树'
    AND store_id = 101
    AND sale_date BETWEEN '2023-07-01' AND '2023-07-31'
) AS current_month
CROSS JOIN (
    SELECT SUM(quantity) AS sales
    FROM sales_records
    WHERE product_name = '蚂蚁上树'
    AND store_id = 101
    AND sale_date BETWEEN '2022-07-01' AND '2022-07-31'
) AS last_year;
```

## 案例20：智能推荐系统候选商品筛选
**业务场景**：餐饮连锁企业需要分析各门店招牌菜品的年度销售增长情况。  
**SQL书写逻辑**：
1. 分别查询今年7月和去年7月的销售总量
2. 使用CROSS JOIN将两个结果集合并
3. 计算同比增长率：(今年销量-去年销量)/去年销量*100
4. 保留两位小数输出结果

```sql
SELECT
    current_month.sales AS current_sales,
    last_year.sales AS last_year_sales,
    ROUND((current_month.sales - last_year.sales) / last_year.sales * 100, 2) AS growth_rate
FROM (
    SELECT SUM(quantity) AS sales
    FROM sales_records
    WHERE product_name = '蚂蚁上树'
    AND store_id = 101
    AND sale_date BETWEEN '2023-07-01' AND '2023-07-31'
) AS current_month
CROSS JOIN (
    SELECT SUM(quantity) AS sales
    FROM sales_records
    WHERE product_name = '蚂蚁上树'
    AND store_id = 101
    AND sale_date BETWEEN '2022-07-01' AND '2022-07-31'
) AS last_year;
```

## 案例21：计算用户购买路径转化漏斗
**业务场景**：餐饮连锁企业需要分析各门店招牌菜品的年度销售增长情况。  
**SQL书写逻辑**：
1. 分别查询今年7月和去年7月的销售总量
2. 使用CROSS JOIN将两个结果集合并
3. 计算同比增长率：(今年销量-去年销量)/去年销量*100
4. 保留两位小数输出结果

```sql
SELECT
    current_month.sales AS current_sales,
    last_year.sales AS last_year_sales,
    ROUND((current_month.sales - last_year.sales) / last_year.sales * 100, 2) AS growth_rate
FROM (
    SELECT SUM(quantity) AS sales
    FROM sales_records
    WHERE product_name = '蚂蚁上树'
    AND store_id = 101
    AND sale_date BETWEEN '2023-07-01' AND '2023-07-31'
) AS current_month
CROSS JOIN (
    SELECT SUM(quantity) AS sales
    FROM sales_records
    WHERE product_name = '蚂蚁上树'
    AND store_id = 101
    AND sale_date BETWEEN '2022-07-01' AND '2022-07-31'
) AS last_year;
```

## 案例22：计算用户RFM模型（最近购买时间、购买频次、消费金额）
**业务场景**：餐饮连锁企业需要分析各门店招牌菜品的年度销售增长情况。  
**SQL书写逻辑**：
1. 分别查询今年7月和去年7月的销售总量
2. 使用CROSS JOIN将两个结果集合并
3. 计算同比增长率：(今年销量-去年销量)/去年销量*100
4. 保留两位小数输出结果

```sql
SELECT
    current_month.sales AS current_sales,
    last_year.sales AS last_year_sales,
    ROUND((current_month.sales - last_year.sales) / last_year.sales * 100, 2) AS growth_rate
FROM (
    SELECT SUM(quantity) AS sales
    FROM sales_records
    WHERE product_name = '蚂蚁上树'
    AND store_id = 101
    AND sale_date BETWEEN '2023-07-01' AND '2023-07-31'
) AS current_month
CROSS JOIN (
    SELECT SUM(quantity) AS sales
    FROM sales_records
    WHERE product_name = '蚂蚁上树'
    AND store_id = 101
    AND sale_date BETWEEN '2022-07-01' AND '2022-07-31'
) AS last_year;
```

## 案例23：计算A/B测试结果统计显著性
**业务场景**：餐饮连锁企业需要分析各门店招牌菜品的年度销售增长情况。  
**SQL书写逻辑**：
1. 分别查询今年7月和去年7月的销售总量
2. 使用CROSS JOIN将两个结果集合并
3. 计算同比增长率：(今年销量-去年销量)/去年销量*100
4. 保留两位小数输出结果

```sql
SELECT
    current_month.sales AS current_sales,
    last_year.sales AS last_year_sales,
    ROUND((current_month.sales - last_year.sales) / last_year.sales * 100, 2) AS growth_rate
FROM (
    SELECT SUM(quantity) AS sales
    FROM sales_records
    WHERE product_name = '蚂蚁上树'
    AND store_id = 101
    AND sale_date BETWEEN '2023-07-01' AND '2023-07-31'
) AS current_month
CROSS JOIN (
    SELECT SUM(quantity) AS sales
    FROM sales_records
    WHERE product_name = '蚂蚁上树'
    AND store_id = 101
    AND sale_date BETWEEN '2022-07-01' AND '2022-07-31'
) AS last_year;
```

## 案例24：计算股票价格波动率（滚动标准差）
**业务场景**：餐饮连锁企业需要分析各门店招牌菜品的年度销售增长情况。  
**SQL书写逻辑**：
1. 分别查询今年7月和去年7月的销售总量
2. 使用CROSS JOIN将两个结果集合并
3. 计算同比增长率：(今年销量-去年销量)/去年销量*100
4. 保留两位小数输出结果

```sql
SELECT
    current_month.sales AS current_sales,
    last_year.sales AS last_year_sales,
    ROUND((current_month.sales - last_year.sales) / last_year.sales * 100, 2) AS growth_rate
FROM (
    SELECT SUM(quantity) AS sales
    FROM sales_records
    WHERE product_name = '蚂蚁上树'
    AND store_id = 101
    AND sale_date BETWEEN '2023-07-01' AND '2023-07-31'
) AS current_month
CROSS JOIN (
    SELECT SUM(quantity) AS sales
    FROM sales_records
    WHERE product_name = '蚂蚁上树'
    AND store_id = 101
    AND sale_date BETWEEN '2022-07-01' AND '2022-07-31'
) AS last_year;
```

## 案例25：计算社交媒体用户互动网络（共同关注关系）
**业务场景**：餐饮连锁企业需要分析各门店招牌菜品的年度销售增长情况。  
**SQL书写逻辑**：
1. 分别查询今年7月和去年7月的销售总量
2. 使用CROSS JOIN将两个结果集合并
3. 计算同比增长率：(今年销量-去年销量)/去年销量*100
4. 保留两位小数输出结果

```sql
SELECT
    current_month.sales AS current_sales,
    last_year.sales AS last_year_sales,
    ROUND((current_month.sales - last_year.sales) / last_year.sales * 100, 2) AS growth_rate
FROM (
    SELECT SUM(quantity) AS sales
    FROM sales_records
    WHERE product_name = '蚂蚁上树'
    AND store_id = 101
    AND sale_date BETWEEN '2023-07-01' AND '2023-07-31'
) AS current_month
CROSS JOIN (
    SELECT SUM(quantity) AS sales
    FROM sales_records
    WHERE product_name = '蚂蚁上树'
    AND store_id = 101
    AND sale_date BETWEEN '2022-07-01' AND '2022-07-31'
) AS last_year;
```